// gcc -DSELF_TESTING -o stribog_test main.c stribog.c
// ./stribog_test
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

#include "stribog_data.h"

// Сложение двух 512-битных чисел по модулю 2^512
void AddModulo512(const unsigned char *a, // первое 512-битное число 
				const unsigned char *b,	// Второе 512-битное число
				 unsigned char *c) // результат сложения
{
	int t = 0;

	for (int i = 63; i >= 0; i--) // Обработка байтов от младших к старшим
	{
		t = a[i] + b[i] + (t >> 8); // сложение + перенос
		c[i] = t & 0xFF; // сохранение младшего байта
	}
}


// побитовая операция XOR между двумя 512-битными блоками данных
void AddXor512(const void *a, //первое слово
	 const void *b, // второе слово
	  void *c) // результат
{
	const long long *A = a, *B = b;
	unsigned long long *C = c; 

	for (int i = 0; i < 8; i++)
	{
		C[i] = A[i] ^ B[i]; // XOR для каждого 64-битного слова
	}
}

// Табличная подстановка
void S(unsigned char *state)
{
	for (int i = 0; i < 64; i++)
	{
		state[i] = Sbox[state[i]];
	}
}

// Смешивает биты внутри байтов
void L(unsigned char *state)						  // state - указатель на состояние (64 байта (8 строк по 8 байт))
{
	unsigned long long v = 0; 						  // Аккумулятор новой 64-битной строки

	for (int i = 0; i < 8; i++)						  // Для каждой из 8 строк состояния
	{
		v = 0;
		for (int k = 0; k < 8; k++) 				  // Для каждого из 8 байтов строки
		{
			for (int j = 0; j < 8; j++) 			  // Пробегаем биты байта от старшего к младшему
			{
				if ((state[i*8+k] & (1<<(7-j))) != 0) // Если бит установлен
					v ^= A[k*8+j]; 					  // Добавляем XOR с соответствующим значением из таблицы A
			}
		}
		for (int k = 0; k < 8; k++)		    			// Записываем полученное значение обратно в state
		{
			state[i*8+k] = (v & ((unsigned long long)0xFF << (7-k)*8)) >> (7-k)*8;
		}
	}
}

// Перестановка байтов по таблице Tau
void P(unsigned char *state)
{
	unsigned char t[64] = {};

	for (int i = 0; i < 64; i++)
	{
		t[i] = state[Tau[i]];
	}

	memcpy(state,t,64);
}

// Обновление 512-битного ключа K для раунда i
// Формирование временного ключа K на каждом раунде функции E(K, m)
void KeySchedule(unsigned char *K, int i)
{
	AddXor512(K,C[i],K); // K ^= C[i]

  	S(K);
	P(K);
	L(K);
} 



// Раундовая функция (шифрование блока m с параметром K)
void E(unsigned char *K, const unsigned char *m, unsigned char *state)
{
	AddXor512(m, K, state); 	// state = m ^ K

  for(int i = 0; i < 12; i++)
  {
    S(state);
    P(state);
    L(state);
    KeySchedule(K,i);
	AddXor512(state,K,state); // state ^= K
  }
}

// Функция сжатия (h -- внутренне состояние хэш-функции)
void g_N(const unsigned char *N, unsigned char *h, const unsigned char *m)
{
	unsigned char t[64], K[64];

	AddXor512(N, h, K); // K = N ^ h

  S(K);
  P(K);
  L(K);

  E(K, m, t); 		// t = E_K(m)

  AddXor512(t,h,t); // t ^= h
  AddXor512(t,m,h); // h = t ^ m
}




// Основная функция вычисления хэша (IV = 0^512, length -- длина сообщения в битах)
void hash_512(const unsigned char *message, unsigned long long length, unsigned char *out)
{
	unsigned char IV[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};

	unsigned char v512[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00
	};

	unsigned char v0[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};

	// Сумма всех обработанных блоков данных
	unsigned char Sigma[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};

	// Счетчик обработанной длины в битах
	unsigned char N[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};

	unsigned char m[64], *hash = IV;
	unsigned long long len = length;

	while (len >= 512)
	{
		memcpy(m, message + len/8 - 63 - ( (len & 0x7) == 0 ), 64);

		g_N(N, hash, m);				// Компрессия блока m с параметром N и состоянием h
		AddModulo512(N, v512, N);		// N += 512			
		AddModulo512(Sigma, m, Sigma); 	// Sigma += m
		len -= 512; 					// Обрезать m, убрав последние 512 бит
	}

	memset(m, 0, 64);
	memcpy(m + 63 - len/8 + ( (len & 0x7) == 0 ), message, len/8 + 1 - ( (len & 0x7) == 0 ));

	// Обработка последнего блока сообщения
	m[ 63 - len/8 ] |= (1 << (len & 0x7));				 	// Дополнение последнего блока до 512 бит

	g_N(N, hash, m); 
	v512[63] = len & 0xFF;
	v512[62] = len >> 8;
	AddModulo512(N, v512, N); 											

	AddModulo512(Sigma, m, Sigma);

	g_N(v0, hash, N); 
	g_N(v0, hash, Sigma);

	memcpy(out, hash, 64);

	// Для хеш-функции с длиной выхода в 512 бит возвращаем h 
	// в качестве результата. Для функции с длиной выхода 256 бит 
	// возвращаем MSB256(h). 
}
